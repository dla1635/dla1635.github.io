# 그래프

**단순 경로와 단순 사이클**

- 경로/ 사이클에서 같은 정점을 두 번 이상 방문하지 않는 경로/사이클
- 특별한 말이 없으면, 일반적으로 사용하는 경로와 사이클은 단순 경로/사이클을 말한다.

**가중치**

- a 에서 b로 이동하는 거리, 이동하는데 필요한 시간 등

**차수**

- 정점과 연결되어 있는 간선의 개수
- 방향 그래프의 경우에는 in-degree, out-degree 로 나누어서 차수를 계산한다.



## 그래프의 표현

![image-20181014193413898](/Users/jongwanlim/Library/Application Support/typora-user-images/image-20181014193413898.png)

- 위와 같은 그래프는 정점이 6개, 간선이 8개 있다.
- 간선에 방향이 없기 때문에, 방향이 없는 그래프이다.
- 정점 : {1,2,3,4,5,6}
- 간선 : {1,2},{1,5},{2,5},...
- 정점은 보통 개수만 저장하면 된다.
- 간선은 모두 저장한다.(그래프를 저장한다는 것은 간선을 저장하는 것)
- 어떤 정점 x와 연결된 간선을 효율적으로 저장하는것이 필요



### 인접 행렬

- 정점의 개수를 v라 했을때
- v*v 크기의 이차원 배열을 이용한다.
- A[ i ][ j ]= 1 (i -> j 간성이 있을때), 0 (없을때)

![image-20181014194105122](/Users/jongwanlim/Library/Application Support/typora-user-images/image-20181014194105122.png)

### 인접리스트

- 리스트를 이용해서 구현한다.
- 동적인 배열이 필요하다.



## 공간 복잡도

- 인접 행렬 : O(V^2)
  - (u, v) 임의 u -> v 존재 유무 구할때 좋음
  - (u, v) 가 존재할때 (v, u) 가 존재하는지 (u,v위치만 바꿔주면 됨)
- 인접 리스트 : O(E)
- 일반적으로  E << V^2





**DFS와 BFS의 목적**

- 시작점으로 부터 모든 정점을 1번씩 방문하는 알고리즘

## DFS

- Stack 을 이용한 알고리즘
- stack을 사용하는데에는 재귀함수호출이 좋음

```c++
// 인접 행렬을 이용한 구현
void dfs(int x) {
    check[x] = true;
    printf("%d", x);
    for(int i = 0 ; i <= n; i++) {
    	if(a[x][i] == 1 && check[i] == false) {
        	dfs(i);
        }
    }
}
```

```c++
// 인접 리스트를 이용한 구현
void dfs(int x) {
    check[x] = true;
    printf("%d", x);
    for(int i = 0 ; i <= a[x].size(); i++) {
    	int y = a[x][i];
    	if(check[y] == false) {
            dfs(y);
    	}
    }
}
```

### **시간 복잡도**

- dfs(x) 는 모든 정점을 한번씩 방문 하므로 정점의 개수 v번만큼 dfs()함수 호출

  -> dfs(x)함수 시간복잡도 * v = 전체 시간 복잡도

  -> ex > 인접행렬에서 for문은 v번 돌게되서 O(v^2) 가 dfs(x)의 시간 복잡도가 된다.

  -> 인접리스트는 O(V + E)의 시간복잡도를 갖는다.



## BFS

- 큐에 넣음과 동시에 방문했다고 처리하여야 한다.

```c++
// 인접 행렬을 통한 구현
queue<int> q;
check[1] = true; q.push(1);
while(!q.empty()) {
    int x = q.front(); q.pop();
    printf("%d", x);
    for(iny i = 0 ; i <= n; i++) {
        if(a[x][i] == 1 && check[i] == false) {
            check[i] = true;
            q.push(i);
        }
    }
}

```

~~~ c++
// 인접 행렬을 통한 구현
queue<int> q;
check[1] = true; q.push(1);
while(!q.empty()) {
    int x = q.front(); q.pop();
    printf("%d", x);
    for(iny i = 0 ; i <= a[x].size(); i++) {
        int y = a[x][i];
        if(check[i] == false) {
            check[i] = true;
            q.push(i);
        }
    }
}
~~~



~~~

~~~



### 시간 복잡도

- 모든 정점을 한번씩 방문하는것이 DFS와 동일 함으로 시간 복잡도 또한 동일하다.





## 연결요소

- 그래프가 아래 그림과 같이 나누어져 있지 않은 경우가 있을 수도 있다.
- 이렇게 나누어진 각각의 그래프를 연결 요소라고 한다.
- 연결 요소에 속한 모든 정점을 연결하는 경로가 있어야 한다.
- 또, 다른 연결 요소에 속한 정점과 연결하는 경로가 있으면 안된다.



## 이분 그래프

![image-20181014190628360](/Users/jongwanlim/Library/Application Support/typora-user-images/image-20181014190628360.png)

- 다음과 같이 두개의 구간으로 나누어 각 구간 안에서의 연결이 없는 그래프 

import java.util.Scanner;

public class Main {
  static int N;
  static int[][] adMatrix;
  public static void main(String[] args) {
​    Scanner sc = new Scanner(System.in);
​    N = sc.nextInt();
​    adMatrix = new int[N+1][N+1];
​    for(int i=1; i<=N; i++) {
​      for(int j=1; j<=N; j++) {
​        adMatrix[i][j] = sc.nextInt();
​      }
​    }
​    //알고리즘 풀이
​    for(int i=1; i<=N; i++) {
​      int[] visit = new int[N+1];
​      DFS(i, visit, false);
​      for(int j=1; j<=N; j++) {
​        System.out.print(visit[j]+" ");
​      }System.out.println();
​    }
  }
  static void DFS(int x, int[] visit, Boolean isFirst) {
​    if(isFirst) { 
​      visit[x] = 1;
​    }
​    for(int i=1; i<=N; i++) {
​      if(adMatrix[x][i]==1 && visit[i]==0) {
​        DFS(i, visit, true);        
​      }
​       }

  }
}